<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/HeaderAndFooter.css">
    <link rel="stylesheet" href="css/laminate-constructor.css">
    <title>Конструктор комнаты - ПолиАрт</title>
    <style>
       /* Стили для цветовых кругляшков */
.color-groups-container {
    display: contents;
    width: 500px;
    max-height: 300px;
    overflow-y: auto;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 8px;
    background: #fff;
}

.color-group:last-child {
    margin-bottom: 0;
}

.color-group-title {
    font-weight: bold;
    font-size: 14px;
    color: #333;
    margin-bottom: 8px;
    padding-bottom: 4px;
    border-bottom: 1px solid #eee;
}

.colors-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    width: 100%;
}

.color-circle-option {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    padding: 5px;
    border-radius: 5px;
    transition: all 0.2s ease;
    min-width: 70px;
}

.color-circle-option:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    background-color: #e0e0e0;
    border: 1px solid #007bff;
}

.color-circle-option.selected {
    background-color: #e3f2fd;
    border: 2px solid #2196f3;
}

.color-circle {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-bottom: 5px;
    position: relative;
    border: 2px solid #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.color-checkmark {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 16px;
    font-weight: bold;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    display: none;
}

.color-circle-name {
    font-size: 11px;
    text-align: center;
    max-width: 60px;
    word-wrap: break-word;
    color: #333;
}
    </style>
</head>
<body>
    <header class="header"></header>

    <div class="constructor-container">
        <div class="settings-panel">
    <div class="panel-section">
        <h2 class="section-title">Параметры комнаты</h2>
        <div class="dimensions-container">
            <div class="input-group">
                <label for="room-length">Длина (м)</label>
                <input type="number" id="room-length" min="5" max="100" step="0,1" value="5">
            </div>
            <div class="input-group">
                <label for="room-width">Ширина (м)</label>
                <input type="number" id="room-width" min="5" max="100" step="0.1" value="5">
            </div>
        </div>
        <div class="area-display">
            Площадь: <span id="room-area">20</span> м²
        </div>
    </div>
    <!-- ДОБАВЛЯЕМ ОДНУ СЕКЦИЮ ДЛЯ ЦВЕТОВ -->
    <div class="panel-section">
        <h2 class="section-title">Выбор цвета</h2>
        
        <!-- Контейнер для кругляшков с цветами -->
        <div class="textures-container" id="textures-container">
            <div class="texture-placeholder">
                Загрузка цветов...
            </div>
        </div>
        
        <!-- Скрытый select для работы с цветом -->
        <select id="laminate-color-select" style="display: none;">
            <option value="">-- Выберите цвет --</option>
        </select>
    </div>
    
    <div class="panel-section">
        <h2 class="section-title">Дополнительные опции</h2>
        <div class="checkbox-group">
            <input type="checkbox" id="underlay" checked>
            <label for="underlay">Включить подложку</label>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="plinth" checked>
            <label for="plinth">Включить плинтус</label>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="thresholds">
            <label for="thresholds">Включить пороги</label>
        </div>
    </div>
    
    <div class="panel-section">
        <h2 class="section-title">Итоговая стоимость</h2>
        <div class="cost-breakdown">
            <div class="cost-item">
                <span>Ламинат:</span>
                <span id="laminate-cost">8000 руб</span>
            </div>
            <div class="cost-item">
                <span>Подложка:</span>
                <span id="underlay-cost">1000 руб</span>
            </div>
            <div class="cost-item">
                <span>Плинтус:</span>
                <span id="plinth-cost">1500 руб</span>
            </div>
            <div class="cost-item">
                <span>Пороги:</span>
                <span id="thresholds-cost">0 руб</span>
            </div>
            <div class="cost-total">
                <span>Итого:</span>
                <span id="total-cost">10500 руб</span>
            </div>
        </div>
        
        <div class="action-buttons">
            <button class="btn btn-accent" id="order-btn">Оформить заказ</button>
            <button class="btn btn-primary" id="measure-btn">Вызвать замерщика</button>
        </div>
    </div>
</div>
        
        <div class="visualization-panel">
            <div id="room-3d">
                <div class="loading" id="loading-message">Создание 3D модели комнаты...</div>
                <div class="view-controls">
                    <button class="view-btn" id="top-view">Вид сверху</button>
                    <button class="view-btn" id="perspective-view">3D вид</button>
                    <button class="view-btn" id="reset-view">Сбросить вид</button>
                </div>
            </div>
            <div class="controls-info">
                <div>Используйте мышь для вращения и колесо для масштабирования</div>
                <div>Текущий материал: <span id="current-material">Классический дуб</span></div>
            </div>
        </div>
    </div>

    <!-- Модальное окно для оформления заказа -->
    <div id="orderModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Оформление заказа</h2>
            <div class="modal-body" id="orderModalBody">
                <!-- Содержимое будет вставлено через JavaScript -->
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-accent" id="confirmOrderBtn">Подтвердить заказ</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно для вызова замерщика -->
    <div id="measureModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Вызов замерщика</h2>
            <div class="modal-body">
                <p>Запрос на вызов замерщика отправлен! Мы свяжемся с вами в ближайшее время.</p>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-primary close-modal">ОК</button>
            </div>
        </div>
    </div>

    <footer class="footer"></footer>

    <script src="js/header.js"></script>
    <script src="js/footer.js"></script>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script> 
    <script>
        console.log('Начало инициализации конструктора');
console.log('Доступные элементы:', {
    colorSelect: document.getElementById('laminate-color-select'),
    texturesContainer: document.getElementById('textures-container'),
    collectionSelect: document.getElementById('collection-select')
});

// Глобальная функция для применения цвета
window.applyColorToConstructor = applyColorToConstructor;

        // Data for laminate collections with real texture paths
        const laminateData = {
    premium: {
        name: "Премиум коллекция",
        price: 1200,
        textures: [
            { 
                id: 'premium-oak', 
                name: 'Дуб премиум', 
                color: '#8B4513',
                texture: createWoodTexture('#8B4513', 'premium')
            },
            { 
                id: 'premium-walnut', 
                name: 'Орех премиум', 
                color: '#A0522D',
                texture: createWoodTexture('#A0522D', 'premium')
            },
            { 
                id: 'premium-ash', 
                name: 'Ясень премиум', 
                color: '#D2B48C',
                texture: createWoodTexture('#D2B48C', 'premium')
            }
        ]
    },
    classic: {
        name: "Классическая коллекция",
        price: 800,
        textures: [
            { 
                id: 'classic-oak', 
                name: 'Классический дуб', 
                color: '#8B4513',
                texture: createWoodTexture('#8B4513', 'classic')
            },
            { 
                id: 'classic-walnut', 
                name: 'Классический орех', 
                color: '#A0522D',
                texture: createWoodTexture('#A0522D', 'classic')
            },
            { 
                id: 'classic-ash', 
                name: 'Классический ясень', 
                color: '#DEB887',
                texture: createWoodTexture('#DEB887', 'classic')
            },
            { 
                id: 'classic-beech', 
                name: 'Классический бук', 
                color: '#F5DEB3',
                texture: createWoodTexture('#F5DEB3', 'classic')
            }
        ]
    },
    modern: {
        name: "Современная коллекция",
        price: 900,
        textures: [
            { 
                id: 'modern-gray', 
                name: 'Серый современный', 
                color: '#696969',
                texture: createModernTexture('#696969')
            },
            { 
                id: 'modern-white', 
                name: 'Белый современный', 
                color: '#F5F5F5',
                texture: createModernTexture('#F5F5F5')
            },
            { 
                id: 'modern-black', 
                name: 'Черный современный', 
                color: '#2F2F2F',
                texture: createModernTexture('#2F2F2F')
            }
        ]
    },
    eco: {
        name: "Эко коллекция",
        price: 700,
        textures: [
            { 
                id: 'eco-bamboo', 
                name: 'Бамбук эко', 
                color: '#F0E68C',
                texture: createEcoTexture('#F0E68C')
            },
            { 
                id: 'eco-cork', 
                name: 'Пробка эко', 
                color: '#D2691E',
                texture: createEcoTexture('#D2691E')
            }
        ]
    }
};

// Добавляем обработчики для модальных окон
const orderModal = document.getElementById('orderModal');
const measureModal = document.getElementById('measureModal');
const closeModalBtns = document.querySelectorAll('.close, .close-modal');

// Обработчик для кнопки "Оформить заказ"
document.getElementById('order-btn').addEventListener('click', function(e) {
    e.preventDefault();
    showOrderModal();
});

// Обработчик для кнопки "Вызвать замерщика"
document.getElementById('measure-btn').addEventListener('click', function(e) {
    e.preventDefault();
    measureModal.style.display = 'block';
});

// Обработчики для закрытия модальных окон
closeModalBtns.forEach(btn => {
    btn.addEventListener('click', function() {
        orderModal.style.display = 'none';
        measureModal.style.display = 'none';
    });
});

// Закрытие окна при клике вне его содержимого
window.addEventListener('click', function(event) {
    if (event.target === orderModal) {
        orderModal.style.display = 'none';
    }
    if (event.target === measureModal) {
        measureModal.style.display = 'none';
    }
});

// Функция для отображения модального окна заказа
function showOrderModal() {
    const collection = laminateData[currentCollection];
    const laminateCost = currentRoomArea * collection.price;
    const underlayCost = underlayEnabled ? currentRoomArea * underlayPrice : 0;
    const length = parseFloat(roomLengthInput.value);
    const width = parseFloat(roomWidthInput.value);
    const plinthCost = baseboardsVisible ? (length + width) * 2 * 150 : 0;
    const thresholdsCost = document.getElementById('thresholds').checked ? 500 : 0;
    const totalCost = laminateCost + underlayCost + plinthCost + thresholdsCost;

    let summaryHTML = `
        <p><strong>Детали заказа:</strong></p>
        <p>• Площадь комнаты: ${currentRoomArea} м²</p>
        <p>• Коллекция: ${collection.name}</p>
        <p>• Материал: ${currentTextureName}</p>
        <p>• Ламинат: ${laminateCost.toFixed(0)} руб</p>
        <p>• Подложка: ${underlayCost.toFixed(0)} руб</p>`;
    if (baseboardsVisible) {
        summaryHTML += `<p>• Плинтус: ${plinthCost.toFixed(0)} руб</p>`;
    }
    if (thresholdsCost > 0) {
        summaryHTML += `<p>• Пороги: ${thresholdsCost} руб</p>`;
    }
    summaryHTML += `
        <p><strong>ИТОГО: ${totalCost.toFixed(0)} руб</strong></p>
        <p>С вами свяжется наш менеджер для подтверждения заказа.</p>
    `;

    document.getElementById('orderModalBody').innerHTML = summaryHTML;
    orderModal.style.display = 'block';
}

// Функция для загрузки цветов ламината из базы данных
async function loadLaminateColorsFromDB() {
    try {
        console.log('Загрузка цветов ламината из базы данных...');
        
        const response = await fetch('http://127.0.0.1:8090/api/collections/laminate/records');
        
        if (response.ok) {
            const result = await response.json();
            const laminateItems = result.items || [];
            
            // Собираем все уникальные цвета из базы данных
            const uniqueColors = new Set();
            
            laminateItems.forEach(item => {
                if (item.color) {
                    if (Array.isArray(item.color)) {
                        item.color.forEach(color => {
                            if (color && typeof color === 'string' && color.trim()) {
                                uniqueColors.add(color.trim());
                            }
                        });
                    } else if (typeof item.color === 'string' && item.color.trim()) {
                        uniqueColors.add(item.color.trim());
                    }
                }
            });
            
            console.log('Уникальные цвета из БД:', Array.from(uniqueColors));
            return Array.from(uniqueColors);
        } else {
            console.warn('Не удалось загрузить цвета из БД, статус:', response.status);
        }
    } catch (error) {
        console.error('Ошибка загрузки цветов из БД:', error);
    }
    
    return [];
}

// Функция для загрузки коллекций ламината из базы данных
async function loadLaminateCollectionsFromDB() {
    try {
        console.log('Загрузка коллекций ламината из базы данных...');
        
        const response = await fetch('http://127.0.0.1:8090/api/collections/laminate/records');
        
        if (response.ok) {
            const result = await response.json();
            const laminateItems = result.items || [];
            
            // Собираем уникальные типы (коллекции)
            const uniqueTypes = new Set();
            const collectionsData = {};
            
            laminateItems.forEach(item => {
                if (item.type) {
                    if (Array.isArray(item.type)) {
                        item.type.forEach(type => {
                            if (type && typeof type === 'string') {
                                const trimmedType = type.trim();
                                uniqueTypes.add(trimmedType);
                                
                                // Добавляем цвет в коллекцию
                                if (!collectionsData[trimmedType]) {
                                    collectionsData[trimmedType] = {
                                        name: trimmedType,
                                        colors: new Set(),
                                        items: []
                                    };
                                }
                                
                                // Добавляем цвета
                                if (item.color) {
                                    if (Array.isArray(item.color)) {
                                        item.color.forEach(color => {
                                            if (color) collectionsData[trimmedType].colors.add(color.trim());
                                        });
                                    } else if (typeof item.color === 'string') {
                                        collectionsData[trimmedType].colors.add(item.color.trim());
                                    }
                                }
                                
                                collectionsData[trimmedType].items.push(item);
                            }
                        });
                    } else if (typeof item.type === 'string' && item.type.trim()) {
                        const trimmedType = item.type.trim();
                        uniqueTypes.add(trimmedType);
                        
                        if (!collectionsData[trimmedType]) {
                            collectionsData[trimmedType] = {
                                name: trimmedType,
                                colors: new Set(),
                                items: []
                            };
                        }
                        
                        if (item.color) {
                            if (Array.isArray(item.color)) {
                                item.color.forEach(color => {
                                    if (color) collectionsData[trimmedType].colors.add(color.trim());
                                });
                            } else if (typeof item.color === 'string') {
                                collectionsData[trimmedType].colors.add(item.color.trim());
                            }
                        }
                        
                        collectionsData[trimmedType].items.push(item);
                    }
                }
            });
            
            console.log('Коллекции из БД:', Object.keys(collectionsData));
            console.log('Данные коллекций:', collectionsData);
            
            return collectionsData;
        } else {
            console.warn('Не удалось загрузить коллекции из БД, статус:', response.status);
        }
    } catch (error) {
        console.error('Ошибка загрузки коллекций из БД:', error);
    }
    
    return {};
}

// Функция для обновления выпадающих списков
async function updateDropdownsFromDB() {
    const collectionsData = await loadLaminateCollectionsFromDB();
    
    if (!collectionsData || Object.keys(collectionsData).length === 0) {
        console.log('Нет данных из БД, используем демо-данные');
        
        // Устанавливаем демо-коллекцию
        currentCollection = 'classic';
        if (collectionSelect) {
            collectionSelect.innerHTML = '';
            Object.keys(laminateData).forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = laminateData[key].name;
                collectionSelect.appendChild(option);
            });
            collectionSelect.value = currentCollection;
        }
        
        // Загружаем текстуры для демо-коллекции
        loadTextures();
        return;
    }
    
    // Обновляем список коллекций
    if (collectionSelect) {
        // Сохраняем текущее значение
        const currentValue = collectionSelect.value;
        
        // Очищаем список
        collectionSelect.innerHTML = '';
        
        // Добавляем коллекции из БД
        Object.keys(collectionsData).forEach(collectionName => {
            const option = document.createElement('option');
            option.value = collectionName;
            option.textContent = collectionName;
            collectionSelect.appendChild(option);
        });
        
        // Устанавливаем значение по умолчанию
        if (collectionSelect.options.length > 0) {
            if (currentValue && Array.from(collectionSelect.options).some(opt => opt.value === currentValue)) {
                collectionSelect.value = currentValue;
                currentCollection = currentValue;
            } else {
                collectionSelect.selectedIndex = 0;
                currentCollection = collectionSelect.options[0].value;
            }
        }
    }
    
    // Сразу загружаем текстуры для текущей коллекции
    loadTextures();
}

// Функция для загрузки конкретного продукта из БД
async function loadProductFromDatabase(productId) {
    try {
        console.log('Загрузка данных о продукте из БД...', productId);
        
        const response = await fetch(`http://127.0.0.1:8090/api/collections/laminate/records/${productId}`);
        
        if (response.ok) {
            const product = await response.json();
            console.log('Данные продукта из БД:', product);
            return product;
        } else {
            console.warn('Не удалось загрузить данные из БД, статус:', response.status);
        }
    } catch (error) {
        console.error('Ошибка загрузки из БД:', error);
    }
    
    return null;
}

// Функции для создания программных текстур
function createWoodTexture(baseColor, type) {
    // Создаем canvas для генерации текстуры дерева
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    
    // Основной цвет
    ctx.fillStyle = baseColor;
    ctx.fillRect(0, 0, 256, 256);
    
    // Добавляем текстуру дерева
    ctx.strokeStyle = adjustColor(baseColor, -30);
    ctx.lineWidth = type === 'premium' ? 1 : 2;
    ctx.globalAlpha = 0.7;
    
    // Вертикальные полосы (волокна дерева)
    for (let i = 0; i < 256; i += 8) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i + Math.random() * 4 - 2, 256);
        ctx.stroke();
    }
    
    // Горизонтальные прожилки
    ctx.strokeStyle = adjustColor(baseColor, 20);
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.8;
    for (let i = 0; i < 256; i += 20) {
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(256, i + Math.random() * 10 - 5);
        ctx.stroke();
    }
    
    // Узоры для премиум коллекции
    if (type === 'premium') {
        ctx.globalAlpha = 0.4;
        ctx.strokeStyle = adjustColor(baseColor, -50);
        for (let i = 0; i < 256; i += 15) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, 256);
            ctx.stroke();
        }
    }
    
    return canvas.toDataURL();
}

function createModernTexture(color) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    
    // Сплошной цвет с легкой текстурой
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 256, 256);
    
    // Добавляем современную текстуру (точки)
    ctx.fillStyle = adjustColor(color, 20);
    for (let i = 0; i < 100; i++) {
        const x = Math.random() * 256;
        const y = Math.random() * 256;
        const size = Math.random() * 2;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    return canvas.toDataURL();
}

function createEcoTexture(color) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    
    // Основной цвет
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 256, 256);
    
    // Текстура бамбука/пробки
    ctx.strokeStyle = adjustColor(color, -40);
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.7;
    
    // Вертикальные полосы для бамбука
    for (let i = 10; i < 246; i += 15) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, 256);
        ctx.stroke();
    }
    
    // Горизонтальные линии
    ctx.strokeStyle = adjustColor(color, 30);
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.8;
    for (let i = 0; i < 256; i += 8) {
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(256, i);
        ctx.stroke();
    }
    
    return canvas.toDataURL();
}

// Вспомогательная функция для изменения цвета
function adjustColor(hex, percent) {
    // Конвертируем hex в RGB
    let r = parseInt(hex.slice(1, 3), 16);
    let g = parseInt(hex.slice(3, 5), 16);
    let b = parseInt(hex.slice(5, 7), 16);
    
    // Изменяем яркость
    r = Math.min(255, Math.max(0, r + percent));
    g = Math.min(255, Math.max(0, g + percent));
    b = Math.min(255, Math.max(0, b + percent));
    
    // Конвертируем обратно в hex
    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

        // Функция для тестирования загрузки текстур
function testTextureLoading() {
    console.log('Testing texture loading...');
    
    laminateData.classic.textures.forEach(texture => {
        const img = new Image();
        img.onload = function() {
            console.log('✓ Texture available:', texture.texture);
        };
        img.onerror = function() {
            console.log('✗ Texture not found:', texture.texture);
        };
        img.src = texture.texture;
    });
}
        // DOM elements
        const roomLengthInput = document.getElementById('room-length');
        const roomWidthInput = document.getElementById('room-width');
        const roomAreaDisplay = document.getElementById('room-area');
        const currentMaterialDisplay = document.getElementById('current-material');
        const topViewBtn = document.getElementById('top-view');
        const perspectiveViewBtn = document.getElementById('perspective-view');
        const resetViewBtn = document.getElementById('reset-view');
        const loadingMessage = document.getElementById('loading-message');

        // Current state
        let currentRoomArea = 20;
        let currentCollection = 'classic';
        let currentTexture = 'classic-oak';
        let currentTextureName = 'Классический дуб';
        let currentTextureColor = '#8B4513';
        let currentTexturePath = laminateData.classic.textures[0].texture;

        // Three.js variables
        let scene, camera, renderer, controls;
        let room, floor;
        let furniture = [];
        let textureLoader = new THREE.TextureLoader();
        let baseboards = [];
        let baseboardsVisible = true;
        let underlayEnabled = true;
        let underlayPrice = 50; // цена за м²

       // Вызовем в init()
function init() {
    console.log('Initializing application...');
    
    // Сначала инициализируем данные из URL/БД
    initializeConstructorFromURL().then(() => {
        // Затем загружаем текстуры и остальные компоненты
        setupEventListeners();
        calculateArea();
        calculateCost();
        
        // Инициализируем состояние подложки
        underlayEnabled = document.getElementById('underlay').checked;
        updateUnderlayVisibility();
        
        // Инициализируем 3D сцену
        init3D();
        
        console.log('Application initialized successfully');
    }).catch(error => {
        console.error('Error during initialization:', error);
        
        // Загружаем текстуры даже если произошла ошибка
        setupEventListeners();
        calculateArea();
        calculateCost();
        init3D();
    });
}

// Функция для преобразования названия цвета в HEX
function getColorHex(colorName) {
    const colorMap = {
        // Основные цвета ламината
        'коричневый': '#8B4513',
        'бежевый': '#F5DEB3',
        'серый': '#808080',
        'белый': '#FFFFFF',
        'чёрный': '#000000',
        'черный': '#000000',
        'золотистый': '#FFD700',
        'серебристый': '#C0C0C0',
        
        // Деревянные текстуры
        'дуб': '#D2B48C',
        'дуб светлый': '#E8D0A9',
        'дуб темный': '#8B4513',
        'темный дуб': '#654321',
        'орех': '#A0522D',
        'ясень': '#DEB887',
        'ясень светлый': '#F0E68C',
        'ясень темный': '#CD853F',
        'бук': '#F5DEB3',
        'венге': '#3C2F23',
        'вишня': '#DE3163',
        'махагон': '#C04000',
        'мербау': '#8B0000',
        
        // Современные цвета
        'графит': '#2F4F4F',
        'антрацит': '#383838',
        'титан': '#878787',
        'платина': '#E5E4E2',
        'хром': '#DCDCDC',
        
        // Серые оттенки
        'светло-серый': '#D3D3D3',
        'темно-серый': '#696969',
        'пепельный': '#B2BEB5',
        'стальной': '#4682B4'
    };
    
    if (!colorName || typeof colorName !== 'string') {
        return '#8B4513';
    }
    
    const normalized = colorName.toLowerCase().trim();
    
    // Прямое совпадение
    if (colorMap[normalized]) {
        return colorMap[normalized];
    }
    
    // Поиск по частичному совпадению
    for (const [key, value] of Object.entries(colorMap)) {
        if (normalized.includes(key) || key.includes(normalized)) {
            return value;
        }
    }
    
    // Для неизвестных цветов
    console.log('Неизвестный цвет ламината:', normalized);
    return '#8B4513'; // Коричневый по умолчанию
}

// Функция для создания текстуры ламината
function createLaminateTexture(baseColor) {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    
    // Основной фон
    ctx.fillStyle = baseColor;
    ctx.fillRect(0, 0, 512, 512);
    
    // Текстура древесины - вертикальные полосы (волокна)
    ctx.strokeStyle = adjustColor(baseColor, -30);
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.6;
    
    for (let x = 0; x < 512; x += 8) {
        ctx.beginPath();
        ctx.moveTo(x + Math.random() * 3, 0);
        ctx.lineTo(x + Math.random() * 3, 512);
        ctx.stroke();
    }
    
    // Горизонтальные линии (годовые кольца)
    ctx.strokeStyle = adjustColor(baseColor, 20);
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.4;
    
    for (let y = 0; y < 512; y += 20) {
        ctx.beginPath();
        ctx.moveTo(0, y + Math.random() * 5);
        ctx.lineTo(512, y + Math.random() * 5);
        ctx.stroke();
    }
    
    // Добавляем эффект досок ламината
    ctx.strokeStyle = adjustColor(baseColor, -50);
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.3;
    
    // Вертикальные разделители досок
    for (let x = 100; x < 412; x += 104) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, 512);
        ctx.stroke();
    }
    
    // Текстура деревянных досок
    ctx.fillStyle = adjustColor(baseColor, 10);
    ctx.globalAlpha = 0.1;
    
    for (let i = 0; i < 5; i++) {
        const x = i * 104;
        ctx.fillRect(x, 0, 100, 512);
    }
    
    // Добавляем небольшие точки для текстуры
    ctx.fillStyle = adjustColor(baseColor, 30);
    ctx.globalAlpha = 0.05;
    
    for (let i = 0; i < 1000; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const size = Math.random() * 2 + 1;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Блеск ламината
    const gradient = ctx.createLinearGradient(0, 0, 512, 512);
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 512, 512);
    
    return canvas.toDataURL();
}

// Вспомогательная функция для изменения цвета
function adjustColor(hex, percent) {
    // Убираем # если есть
    hex = hex.replace('#', '');
    
    // Конвертируем hex в RGB
    let r = parseInt(hex.slice(0, 2), 16);
    let g = parseInt(hex.slice(2, 4), 16);
    let b = parseInt(hex.slice(4, 6), 16);
    
    // Изменяем яркость
    r = Math.min(255, Math.max(0, r + percent));
    g = Math.min(255, Math.max(0, g + percent));
    b = Math.min(255, Math.max(0, b + percent));
    
    // Конвертируем обратно в hex
    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

// Добавляем в функцию setupEventListeners:
const colorSelect = document.getElementById('laminate-color-select');
if (colorSelect) {
    colorSelect.addEventListener('change', function() {
        const selectedColor = this.value;
        if (selectedColor) {
            console.log('Выбран цвет из списка:', selectedColor);
            
            // Обновляем текущий материал
            const currentMaterialDisplay = document.getElementById('current-material');
            if (currentMaterialDisplay) {
                currentMaterialDisplay.textContent = selectedColor;
            }
            
            // Обновляем 3D модель
            if (floor) {
                // Обновляем текущий цвет текстуры
                currentTextureColor = getColorHex(selectedColor);
                update3DFloorTexture();
            }
        }
    });
}

        // Calculate room area
function calculateArea() {
    const length = parseFloat(roomLengthInput.value);
    const width = parseFloat(roomWidthInput.value);
    // Validation: Ensure minimum value is 5
    if (length < 5) roomLengthInput.value = 5;
    if (width < 5) roomWidthInput.value = 5;
    if (length > 20) roomLengthInput.value = 20;
    if (width > 20) roomWidthInput.value = 20;

    const validLength = parseFloat(roomLengthInput.value);
    const validWidth = parseFloat(roomWidthInput.value);

    currentRoomArea = validLength * validWidth;
    roomAreaDisplay.textContent = currentRoomArea.toFixed(2);
    calculateCost();
    if (scene) {
        update3DRoom();
    }
}

        // Load textures with real images and fallback
function loadTextures() {
    console.log('Загрузка цветов из БД');
    
    const container = document.getElementById('textures-container');
    if (!container) return;
    
    container.innerHTML = '<div class="texture-placeholder">Загрузка цветов...</div>';
    
    // Загружаем все цвета из БД
    loadAllColorsFromDB().then(colors => {
        if (colors && colors.length > 0) {
            createColorCircles(colors);
        } else {
            container.innerHTML = '<div class="texture-placeholder">Цвета не найдены</div>';
        }
    }).catch(error => {
        console.error('Ошибка загрузки цветов:', error);
        container.innerHTML = '<div class="texture-placeholder">Ошибка загрузки цветов</div>';
    });
}

// Функция для загрузки всех цветов из БД
async function loadAllColorsFromDB() {
    try {
        console.log('Загрузка всех цветов ламината из БД...');
        
        const response = await fetch('http://127.0.0.1:8090/api/collections/laminate/records');
        
        if (response.ok) {
            const result = await response.json();
            const laminateItems = result.items || [];
            
            console.log('Все товары ламината:', laminateItems);
            
            // Собираем все уникальные цвета из базы данных
            const uniqueColors = new Set();
            
            laminateItems.forEach(item => {
                if (item.color) {
                    if (Array.isArray(item.color)) {
                        item.color.forEach(color => {
                            if (color && typeof color === 'string' && color.trim()) {
                                uniqueColors.add(color.trim());
                            }
                        });
                    } else if (typeof item.color === 'string' && item.color.trim()) {
                        uniqueColors.add(item.color.trim());
                    }
                }
                
                // Также проверяем поле colors если оно есть
                if (item.colors && Array.isArray(item.colors)) {
                    item.colors.forEach(color => {
                        if (color && typeof color === 'string' && color.trim()) {
                            uniqueColors.add(color.trim());
                        }
                    });
                }
            });
            
            // Если в БД мало цветов, добавляем стандартные
            if (uniqueColors.size === 0) {
                console.log('В БД нет цветов, добавляем стандартные');
                const standardColors = [
                    'Коричневый', 'Бежевый', 'Серый', 'Белый', 'Чёрный',
                    'Темный дуб', 'Золотистый', 'Светлый дуб', 'Орех',
                    'Ясень', 'Бук', 'Венге', 'Вишня', 'Махагон'
                ];
                standardColors.forEach(color => uniqueColors.add(color));
            }
            
            console.log('Все цвета из БД:', Array.from(uniqueColors));
            return Array.from(uniqueColors);
        } else {
            console.warn('Не удалось загрузить цвета из БД, статус:', response.status);
            
            // Если ошибка, возвращаем стандартные цвета
            const standardColors = [
                'Коричневый', 'Бежевый', 'Серый', 'Белый', 'Чёрный',
                'Темный дуб', 'Золотистый', 'Светлый дуб', 'Орех',
                'Ясень', 'Бук', 'Венге', 'Вишня', 'Махагон'
            ];
            return standardColors;
        }
    } catch (error) {
        console.error('Ошибка загрузки цветов из БД:', error);
        
        // В случае ошибки возвращаем стандартные цвета
        const standardColors = [
            'Коричневый', 'Бежевый', 'Серый', 'Белый', 'Чёрный',
            'Темный дуб', 'Золотистый', 'Светлый дуб', 'Орех',
            'Ясень', 'Бук', 'Венге', 'Вишня', 'Махагон'
        ];
        return standardColors;
    }
}

        // Select texture
        // В начале функции selectTexture() добавьте:
function selectTexture(textureId, textureName, texturePath, textureColor) {
    console.log('=== SELECT TEXTURE ===');
    console.log('Название:', textureName);
    console.log('Цвет текстуры:', textureColor);
    console.log('Текущий цвет пола (до):', currentTextureColor);
    
    currentTexture = textureId;
    currentTextureName = textureName;
    currentTexturePath = texturePath;
    currentTextureColor = textureColor;
    
    console.log('Текущий цвет пола (после):', currentTextureColor);
            
            document.querySelectorAll('.texture-option').forEach(option => {
                option.classList.toggle('selected', option.dataset.id === textureId);
            });
            
            currentMaterialDisplay.textContent = textureName;
            
            // Немедленно обновляем пол
            if (floor) {
                update3DFloorTexture();
            }
            updateBaseboardsColor();
        }

        // И добавим обработчик для изменения размеров комнаты
        function updateRoomDimensions() {
            const length = parseFloat(roomLengthInput.value);
            const width = parseFloat(roomWidthInput.value);
            
            // Обновляем геометрию пола
            if (floor) {
                room.remove(floor);
                floor.geometry.dispose();
                
                const newGeometry = new THREE.PlaneGeometry(length, width, 20, 20);
                applyFloorTexture(newGeometry);
            }
            
            // Пересоздаем комнату
            createDetailedRoom();
        }

        // Calculate total cost
function calculateCost() {
    // Используем фиксированную цену за квадратный метр
    const pricePerSqMeter = 1200; // руб/м²
    
    const laminateCost = currentRoomArea * pricePerSqMeter;
    
    // Подложка всегда отображается, но стоимость 0 если выключена
    const underlayCost = underlayEnabled ? currentRoomArea * underlayPrice : 0;
    
    const length = parseFloat(roomLengthInput.value);
    const width = parseFloat(roomWidthInput.value);
    
    // Плинтусы считаем только если они включены
    const plinthCost = baseboardsVisible ? (length + width) * 2 * 150 : 0;
    
    const thresholdsCost = document.getElementById('thresholds').checked ? 500 : 0;
    const totalCost = laminateCost + underlayCost + plinthCost + thresholdsCost;
    
    // Обновляем отображение стоимости
    document.getElementById('laminate-cost').textContent = `${laminateCost.toFixed(0)} руб`;
    document.getElementById('underlay-cost').textContent = `${underlayCost.toFixed(0)} руб`;
    document.getElementById('plinth-cost').textContent = `${plinthCost.toFixed(0)} руб`;
    document.getElementById('thresholds-cost').textContent = `${thresholdsCost} руб`;
    document.getElementById('total-cost').textContent = `${totalCost.toFixed(0)} руб`;
}

        function updateUnderlayVisibility() {
            const underlayCostElement = document.getElementById('underlay-cost');
            const underlayRow = underlayCostElement.closest('.cost-item');
            
            if (underlayEnabled) {
                underlayRow.style.display = 'flex';
                underlayRow.classList.remove('hidden');
                underlayCostElement.textContent = `${(currentRoomArea * underlayPrice).toFixed(0)} руб`;
            } else {
                underlayRow.classList.add('hidden');
                setTimeout(() => {
                    underlayRow.style.display = 'none';
                }, 300);
                underlayCostElement.textContent = '0 руб';
            }
        }
        // Setup event listeners
        function setupEventListeners() {
            roomLengthInput.addEventListener('input', calculateArea);
            roomWidthInput.addEventListener('input', calculateArea);
            
            topViewBtn.addEventListener('click', () => setCameraView('top'));
            perspectiveViewBtn.addEventListener('click', () => setCameraView('perspective'));
            resetViewBtn.addEventListener('click', () => setCameraView('reset'));
            
            // Обработчик для подложки
            document.getElementById('underlay').addEventListener('change', function(e) {
                underlayEnabled = e.target.checked;
                calculateCost();
            });
            
            document.getElementById('plinth').addEventListener('change', function(e) {
                const isChecked = e.target.checked;
                toggleBaseboards(isChecked);
                calculateCost();
            });
            
            document.getElementById('thresholds').addEventListener('change', calculateCost);
            
            document.getElementById('order-btn').addEventListener('click', function(e) {
                e.preventDefault();
                showOrderSummary();
            });
        }

        function updateUnderlayIn3D() {
            // Здесь можно добавить визуальное отображение подложки
            // Например, изменить материал пола или добавить отдельный слой
            console.log('Underlay enabled:', underlayEnabled);
            
            if (underlayEnabled) {
                // Визуальный эффект включенной подложки
                if (floor) {
                    floor.material.roughness = 0.9; // Более матовая поверхность
                }
            } else {
                // Обычный вид пола
                if (floor) {
                    floor.material.roughness = 0.8;
                }
            }
        }

        // Initialize 3D visualization
        function init3D() {
            try {
                console.log('Initializing 3D scene...');
                const container = document.getElementById('room-3d');
                
                if (!container) {
                    throw new Error('3D container not found');
                }
                
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                
                // Camera
                camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(8, 8, 8);
                
                // Renderer
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true
                });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setClearColor(0xf0f0f0, 1);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Clear container and add renderer
                const existingCanvas = container.querySelector('canvas');
                if (existingCanvas) {
                    container.removeChild(existingCanvas);
                }
                container.appendChild(renderer.domElement);
                
                // Controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 3;
                controls.maxDistance = 25;
                
                // Enhanced Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);
                
                const pointLight = new THREE.PointLight(0xffffff, 0.5);
                pointLight.position.set(0, 10, 0);
                scene.add(pointLight);
                
                // Create detailed room
                createDetailedRoom();
                
                // УБЕЖДАЕМСЯ ЧТО ПЛИНТУСЫ СОЗДАНЫ С ТЕКУЩИМ ЦВЕТОМ
                if (baseboards.length > 0) {
                    updateBaseboardsColor();
                }

                // После создания сцены обновляем цвет пола если есть сохраненный цвет
                if (floor && currentTextureColor) {
                    console.log('Применяем сохраненный цвет к полу после создания сцены:', currentTextureColor);
                    floor.material.color = new THREE.Color(currentTextureColor);
                    floor.material.needsUpdate = true;
                }
                
                // Hide loading message
                if (loadingMessage) {
                    loadingMessage.style.display = 'none';
                }
                
                // Animation loop
                animate();
                
                // Handle window resize
                window.addEventListener('resize', onWindowResize);
                
                console.log('3D scene initialized successfully');
                
            } catch (error) {
                console.error('Error initializing 3D:', error);
                if (loadingMessage) {
                    loadingMessage.innerHTML = '<div class="error-message">Ошибка загрузки 3D визуализации<br><small>Попробуйте обновить страницу</small></div>';
                }
            }
        }

        // Create detailed 3D room with windows, doors and furniture
        function createDetailedRoom() {
            if (room) {
                scene.remove(room);
            }
            
            room = new THREE.Group();
            const length = parseFloat(roomLengthInput.value);
            const width = parseFloat(roomWidthInput.value);
            const height = 2.8;
            const wallThickness = 0.15;
            
            // Floor with texture
            const floorGeometry = new THREE.PlaneGeometry(length, width, 20, 20);
            applyFloorTexture(floorGeometry);
            
            // Walls with thickness
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xF8F8FF,
                roughness: 0.7,
                metalness: 0.1
            });
            
            // Back wall with door
            createWallWithDoor(length, height, wallThickness, 0, height/2, -width/2, wallMaterial);
            
            // Left wall
            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, height, width),
                wallMaterial
            );
            leftWall.position.set(-length/2, height/2, 0);
            leftWall.castShadow = true;
            room.add(leftWall);
            
            // ФРОНТАЛЬНАЯ СТЕНА С ОКНОМ
            const frontWallWithWindow = createFrontWallWithWindow(
                length, width, height, wallThickness, wallMaterial
            );
            frontWallWithWindow.position.set(0, height -2.8, width/2);
            frontWallWithWindow.rotation.y = Math.PI -3.141; // Поворот на 180 градусов
            room.add(frontWallWithWindow);
                    
            // Baseboards
            createBaseboards(length, width);
            
            // Add detailed furniture
            addDetailedFurniture(length, width, height);
            
            scene.add(room);
        }

// Apply floor texture with proper scaling
function applyFloorTexture(geometry) {
    console.log('Создание пола с текстурой ламината');
    
    // Создаем материал для ламината
    const material = new THREE.MeshStandardMaterial({ 
        color: new THREE.Color(currentTextureColor),
        roughness: 0.4, // Ламинат более гладкий
        metalness: 0.1,
        side: THREE.DoubleSide
    });
    
    // Если пол существует, обновляем его
    if (floor) {
        room.remove(floor);
        if (floor.material) {
            if (floor.material.map) {
                floor.material.map.dispose();
            }
            floor.material.dispose();
        }
    }
    
    floor = new THREE.Mesh(geometry, material);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    floor.castShadow = true;
    room.add(floor);
    
    // Загружаем текстуру ламината
    const textureURL = createLaminateTexture(currentTextureColor);
    
    textureLoader.load(
        textureURL,
        function(texture) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            
            const length = parseFloat(roomLengthInput.value);
            const width = parseFloat(roomWidthInput.value);
            
            // Размер доски ламината
            const boardLength = 1.2;
            const boardWidth = 0.2;
            
            texture.repeat.set(length / boardLength, width / boardWidth);
            
            floor.material.map = texture;
            floor.material.needsUpdate = true;
            
            console.log('Текстура ламината применена');
        },
        undefined,
        function(error) {
            console.warn('Не удалось загрузить текстуру ламината');
            // Используем только цвет
        }
    );
}

        // Create detailed wall with door
        function createWallWithDoor(length, height, thickness, x, y, z, material) {
            const wallGroup = new THREE.Group();
            
            // Main wall
            const wall = new THREE.Mesh(
                new THREE.BoxGeometry(length, height, thickness),
                material
            );
            wall.position.set(0, 0, 0);
            wall.castShadow = true;
            wallGroup.add(wall);
            
            // Detailed door with frame
            const doorWidth = 0.9;
            const doorHeight = 2.0;
            
            // Door frame
            const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const frameVertical = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, doorHeight + 0.2, 0.05),
                frameMaterial
            );
            frameVertical.position.set(-1 + doorWidth/2, doorHeight/2 - 1.55, thickness/2 + 0.025);
            wallGroup.add(frameVertical);

            const frameVertical2 = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, doorHeight + 0.2, 0.05),
                frameMaterial
            );
            frameVertical2.position.set(-1 - doorWidth/2, doorHeight/2 - 1.55, thickness/2 + 0.025);
            wallGroup.add(frameVertical2);
            
            const frameHorizontal = new THREE.Mesh(
                new THREE.BoxGeometry(doorWidth + 0.0, 0.1, 0.05),
                frameMaterial
            );
            frameHorizontal.position.set(-1, doorHeight - 1.5, thickness/2 + 0.025);
            wallGroup.add(frameHorizontal);
            
            // Door
            const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, thickness + 0.00);
            const doorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.6
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(-1, doorHeight/70 - 0.5, 0.01);
            door.castShadow = true;
            wallGroup.add(door);
            
            // Door handle
            const handleGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.08, 8);
            const handleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.rotation.z = Math.PI / 2;
            handle.position.set(-1 - doorWidth/2 + 0.1, doorHeight/70 - 0.3, thickness/2 + 0.04);
            wallGroup.add(handle);
            
            wallGroup.position.set(x, y, z);
            room.add(wallGroup);
        }

        // Создание фронтальной стены с проемом для окна
        function createFrontWallWithWindow(length, width, height, thickness, material) {
            const wallGroup = new THREE.Group();
            
            // Параметры окна
            const windowWidth = 1.5;
            const windowHeight = 1.2;
            const windowYPosition = 1.5; // Высота от пола до центра окна
            
            // Создаем стену с проемом для окна используя несколько прямоугольников
            const wallColor = material.color;
            
            // Верхняя часть стены (над окном)
            const topWall = new THREE.Mesh(
                new THREE.BoxGeometry(length, height - windowYPosition - windowHeight/2, thickness),
                material
            );
            topWall.position.set(0, (height + windowYPosition + windowHeight/2) / 2, 0);
            wallGroup.add(topWall);
            
            // Нижняя часть стены (под окном)
            const bottomWall = new THREE.Mesh(
                new THREE.BoxGeometry(length, windowYPosition - windowHeight/2, thickness),
                material
            );
            bottomWall.position.set(0, (windowYPosition - windowHeight/2) / 2, 0);
            wallGroup.add(bottomWall);
            
            // Левая часть стены (слева от окна)
            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry(length/2 - windowWidth/2, windowHeight, thickness),
                material
            );
            leftWall.position.set(-(length/2 + windowWidth/2)/2, windowYPosition, 0);
            wallGroup.add(leftWall);
            
            // Правая часть стены (справа от окна)
            const rightWall = new THREE.Mesh(
                new THREE.BoxGeometry(length/2 - windowWidth/2, windowHeight, thickness),
                material
            );
            rightWall.position.set((length/2 + windowWidth/2)/2, windowYPosition, 0);
            wallGroup.add(rightWall);
            
            // Рамка окна
            const frameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.7
            });
            
            // Вертикальные части рамы
            const frameVerticalGeometry = new THREE.BoxGeometry(0.08, windowHeight, 0.1);
            const frameLeft = new THREE.Mesh(frameVerticalGeometry, frameMaterial);
            frameLeft.position.set(-windowWidth/2, windowYPosition, thickness/2 + 0.05);
            wallGroup.add(frameLeft);
            
            const frameRight = new THREE.Mesh(frameVerticalGeometry, frameMaterial);
            frameRight.position.set(windowWidth/2, windowYPosition, thickness/2 + 0.05);
            wallGroup.add(frameRight);
            
            // Горизонтальные части рамы
            const frameHorizontalGeometry = new THREE.BoxGeometry(windowWidth, 0.08, 0.1);
            const frameTop = new THREE.Mesh(frameHorizontalGeometry, frameMaterial);
            frameTop.position.set(0, windowYPosition + windowHeight/2, thickness/2 + 0.05);
            wallGroup.add(frameTop);
            
            const frameBottom = new THREE.Mesh(frameHorizontalGeometry, frameMaterial);
            frameBottom.position.set(0, windowYPosition - windowHeight/2, thickness/2 + 0.05);
            wallGroup.add(frameBottom);
            
            // Стекло окна
            const windowGeometry = new THREE.BoxGeometry(windowWidth - 0.1, windowHeight - 0.1, 0.03);
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.3,
                roughness: 0.1,
                metalness: 0.3
            });
            const window = new THREE.Mesh(windowGeometry, windowMaterial);
            window.position.set(0, windowYPosition, thickness/2 + 0.08);
            wallGroup.add(window);
            
            // Подоконник (внутренний)
            const sillGeometry = new THREE.BoxGeometry(windowWidth + 0.4, 0.05, 0.15);
            const sillMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xDEB887,
                roughness: 0.8
            });
            const sill = new THREE.Mesh(sillGeometry, sillMaterial);
            sill.position.set(0, windowYPosition - windowHeight/2 - 0.025, thickness/2 + 0.075);
            wallGroup.add(sill);
            
            // Подоконник (внешний - с улицы)
            const outerSill = new THREE.Mesh(sillGeometry, sillMaterial);
            outerSill.position.set(0, windowYPosition - windowHeight/2 - 0.025, -thickness/2 - 0.075);
            wallGroup.add(outerSill);
            
            return wallGroup;
        }

        function createBaseboards(length, width) {
            // Удаляем старые плинтусы если есть
            removeBaseboards();
            
            const baseboardMaterial = new THREE.MeshStandardMaterial({ 
                color: new THREE.Color(currentTextureColor), // Берем цвет пола
                roughness: 0.8
            });
            const baseboardHeight = 0.1;
            const baseboardDepth = 0.08;
            
            const baseboardGeometry = new THREE.BoxGeometry(1, baseboardHeight, baseboardDepth);
            
            // Create baseboards around the room
            function createWallBaseboard(wallPosition, isVertical = false) {
                const segments = isVertical ? Math.ceil(width) : Math.ceil(length);
                
                for (let i = 0; i < segments; i++) {
                    const baseboard = new THREE.Mesh(baseboardGeometry, baseboardMaterial);
                    
                    if (isVertical) {
                        baseboard.rotation.y = Math.PI / 2;
                        baseboard.position.set(
                            wallPosition.x, 
                            baseboardHeight/2, 
                            i - width/2 + 0.5
                        );
                    } else {
                        baseboard.position.set(
                            i - length/2 + 0.5, 
                            baseboardHeight/2, 
                            wallPosition.z
                        );
                    }
                    
                    baseboard.castShadow = true;
                    // ДОБАВЛЯЕМ В МАССИВ
                    baseboards.push(baseboard);
                    room.add(baseboard);
                }
            }
            
            // Создаем плинтусы для всех 4 стен
            createWallBaseboard({z: -width/2 + baseboardDepth/2}); // Задняя
            createWallBaseboard({z: width/2 - baseboardDepth/2});  // Передняя
            createWallBaseboard({x: -length/2 + baseboardDepth/2}, true); // Левая
        }

        // Функция для удаления плинтусов
        function removeBaseboards() {
            baseboards.forEach(baseboard => {
                room.remove(baseboard);
                baseboard.material.dispose();
                baseboard.geometry.dispose();
            });
            baseboards = [];
        }

        // Функция для показа/скрытия плинтусов
        function toggleBaseboards(visible) {
            baseboardsVisible = visible;
            baseboards.forEach(baseboard => {
                baseboard.visible = visible;
            });
        }

// Функция для обновления цвета плинтусов
function updateBaseboardsColor() {
    if (!baseboards || baseboards.length === 0) {
        return;
    }
    
    // Обновляем цвет у каждого плинтуса
    baseboards.forEach(baseboard => {
        if (baseboard && baseboard.material) {
            baseboard.material.color = new THREE.Color(currentTextureColor);
            baseboard.material.needsUpdate = true;
        }
    });
}

        // В функции addDetailedFurniture заменяем вызов createDetailedArmchair:
        function addDetailedFurniture(length, width, height) {
        // Clear existing furniture
        furniture.forEach(item => scene.remove(item));
        furniture = [];
        
        // Detailed Bookshelf
        createDetailedBookshelf(-length/2 + 0.2, 0.9, width/3);
        
        // Detailed Cabinet with TV
        createDetailedCabinet(length/2 - 0.25, 0.5, -width/4);
        
        // Detailed Coffee Table
        createDetailedCoffeeTable(0, 0.2, width/4);
        
        // Detailed Armchair - ТЕПЕРЬ С ПОВОРОТОМ
        createDetailedArmchair(length/2 - 1.2, 0.4, width/2 - 0.8, Math.PI); // Смотрит к центру комнаты
        
        // Можно добавить второе кресло с другим поворотом
        createDetailedArmchair(length/2 - 1.2, 0.4, width/2 - 1.5, Math.PI / 2); // Смотрит вправо
    }

        // Create detailed open bookshelf
        function createDetailedBookshelf(x, y, z) {
            const shelfGroup = new THREE.Group();
            const shelfMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7
            });
            
            const shelfWidth = 0.3;   // Глубина шкафа
            const shelfHeight = 1.8;  // Высота шкафа  
            const shelfDepth = 1.2;   // Ширина шкафа
            

            
            // ЛЕВАЯ БОКОВАЯ СТЕНКА
            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry(shelfWidth, shelfHeight, shelfWidth),
                shelfMaterial
            );
            leftWall.position.set(0, shelfHeight -1.7, -shelfDepth/2 + shelfWidth/2);
            leftWall.rotation.y = Math.PI / 2;
            shelfGroup.add(leftWall);
            
            // ПРАВАЯ БОКОВАЯ СТЕНКА
            const rightWall = new THREE.Mesh(
                new THREE.BoxGeometry(shelfWidth, shelfHeight, shelfWidth),
                shelfMaterial
            );
            rightWall.position.set(0, shelfHeight -1.7, shelfDepth/2 - shelfWidth/2);
            rightWall.rotation.y = Math.PI / 2;
            shelfGroup.add(rightWall);
            
            // ПОЛКИ (4 штуки)
            for (let i = 0; i < 4; i++) {
                const shelf = new THREE.Mesh(
                    new THREE.BoxGeometry(shelfWidth - 0.02, 0.02, shelfDepth - shelfWidth),
                    shelfMaterial
                );
                shelf.position.set(0, (i * 0.45) -0.7, 0);
                shelfGroup.add(shelf);
            }
            
            // КНИГИ - заполняем все полки
            const bookColors = [
                0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFDEA6B, // Яркие цвета
                0xFF9999, 0x66CCCC, 0x99CC66, 0xFFCC66, 0xCC99FF, // Пастельные
                0xFF3333, 0x33CC33, 0x3366FF, 0xFF33CC, 0x33FFFF  // Насыщенные
            ];
            
            // Заполняем каждую полку книгами
            for (let shelfIndex = 0; shelfIndex < 4; shelfIndex++) {
                const shelfY = shelfIndex * 0.45 - 0.675; // Позиция Y для текущей полки
                const booksOnShelf = 6 + Math.floor(Math.random() * 3); // 6-8 книг на полке
                
                for (let i = 0; i < booksOnShelf; i++) {
                    // Случайные размеры книг для реалистичности
                    const bookHeight = 0.25 + Math.random() * 0.1; // 0.25-0.35
                    const bookWidth = 0.04 + Math.random() * 0.02; // 0.04-0.06 (толщина)
                    const bookDepth = 0.15 + Math.random() * 0.1;  // 0.15-0.25 (высота корешка)
                    
                    const book = new THREE.Mesh(
                        new THREE.BoxGeometry(bookWidth, bookHeight, bookDepth),
                        new THREE.MeshStandardMaterial({ 
                            color: bookColors[Math.floor(Math.random() * bookColors.length)],
                            roughness: 0.8
                        })
                    );
                    
                    // Позиционируем книгу на полке
                    const bookX = 0; // Все книги у задней стенки
                    const bookY = shelfY + bookHeight/2;
                    const bookZ = -shelfDepth/2 + shelfWidth + (i * (shelfDepth - shelfWidth * 2) / booksOnShelf) + bookDepth/2;
                    
                    book.position.set(bookX, bookY, bookZ);
                    book.rotation.y = Math.PI / 2; // Книги стоят корешками наружу
                    
                    // Немного случайного наклона для реалистичности
                    book.rotation.z = (Math.random() - 0.5) * 0.1;
                    
                    shelfGroup.add(book);
                }
                
            
            }
            
            // ВЕРХНЯЯ КРЫШКА
            const top = new THREE.Mesh(
                new THREE.BoxGeometry(shelfWidth, 0.05, shelfDepth),
                shelfMaterial
            );
            top.position.set(0, shelfHeight - 0.8, 0);
            shelfGroup.add(top);
            
            // НИЖНЯЯ ПОДСТАВКА
            const bottom = new THREE.Mesh(
                new THREE.BoxGeometry(shelfWidth, 0.05, shelfDepth),
                shelfMaterial
            );
            bottom.position.set(0, -0.7, 0);
            shelfGroup.add(bottom);
            
            // НОЖКИ
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const legGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.1, 8);
            
            const legPositions = [
                [-shelfWidth/2 + 0.02, -0.85, -shelfDepth/2 + 0.02],
                [shelfWidth/2 - 0.02, -0.85, -shelfDepth/2 + 0.02],
                [-shelfWidth/2 + 0.02, -0.85, shelfDepth/2 - 0.02],
                [shelfWidth/2 - 0.02, -0.85, shelfDepth/2 - 0.02]
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(pos[0], pos[1], pos[2]);
                shelfGroup.add(leg);
            });
            
            shelfGroup.position.set(x, y, z);
            shelfGroup.castShadow = true;
            furniture.push(shelfGroup);
            scene.add(shelfGroup);
        }

        // ПОДСТАВКА ДЛЯ TV С 3 СТЕНКАМИ
        function createTVWithStand(length, width, height) {
            const tvGroup = new THREE.Group();
            
            // Параметры TV
            const tvWidth = 1.2;
            const tvHeight = 0.7;
            const tvDepth = 0.05;
            const standHeight = 0.6;
            const standDepth = 0.4;
            const standWidth = tvWidth - 0.2;
            
            // ТВ ПАНЕЛЬ
            const tvGeometry = new THREE.BoxGeometry(tvWidth, tvHeight, tvDepth);
            const tvMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                roughness: 0.8,
                metalness: 0.2
            });
            const tv = new THREE.Mesh(tvGeometry, tvMaterial);
            tv.position.set(0, standHeight + tvHeight +0.01, standDepth -0.55 + tvDepth/2);
            tvGroup.add(tv);
            
            // Экран TV
            const screenGeometry = new THREE.BoxGeometry(tvWidth - 0.1, tvHeight - 0.1, 0.01);
            const screenMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000011,
                emissive: 0x111122,
                roughness: 0.1,
                metalness: 0.9
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(0, standHeight + tvHeight +0.01, standDepth -0.55 + tvDepth/2 + 0.025);
            tvGroup.add(screen);
            
            // МАТЕРИАЛ ДЛЯ ПОДСТАВКИ
            const standMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.6,
                metalness: 0.3
            });
            
            // ЛЕВАЯ БОКОВАЯ СТЕНКА
            const leftPanelGeometry = new THREE.BoxGeometry(0.03, standHeight, standDepth);
            const leftPanel = new THREE.Mesh(leftPanelGeometry, standMaterial);
            leftPanel.position.set(-standWidth/2 + 0.015, standHeight/1.5, 0);
            tvGroup.add(leftPanel);
            
            // ПРАВАЯ БОКОВАЯ СТЕНКА
            const rightPanelGeometry = new THREE.BoxGeometry(0.03, standHeight, standDepth);
            const rightPanel = new THREE.Mesh(rightPanelGeometry, standMaterial);
            rightPanel.position.set(standWidth/2 - 0.015, standHeight/1.5, 0);
            tvGroup.add(rightPanel);
            
            // ВЕРХНЯЯ ПАНЕЛЬ (СТОЛЕШНИЦА)
            const topPanelGeometry = new THREE.BoxGeometry(standWidth, 0.03, standDepth);
            const topPanel = new THREE.Mesh(topPanelGeometry, standMaterial);
            topPanel.position.set(0, standHeight + 0.08, 0);
            tvGroup.add(topPanel);
            
            // НИЖНЯЯ ПАНЕЛЬ (ДНО)
            const bottomPanelGeometry = new THREE.BoxGeometry(standWidth - 0.06, 0.03, standDepth - 0.06);
            const bottomPanel = new THREE.Mesh(bottomPanelGeometry, standMaterial);
            bottomPanel.position.set(0, 0.11, 0);
            tvGroup.add(bottomPanel);
            
            // ПОЛКИ ВНУТРИ ПОДСТАВКИ
            const shelfGeometry = new THREE.BoxGeometry(standWidth - 0.1, 0.02, standDepth - 0.1);
            const shelfMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            
            // Средняя полка
            const middleShelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
            middleShelf.position.set(0, standHeight * 0.8, 0);
            tvGroup.add(middleShelf);
            
            // Нижняя полка
            const bottomShelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
            bottomShelf.position.set(0, standHeight * 0.5, 0);
            tvGroup.add(bottomShelf);
            
            // НОЖКИ ПОДСТАВКИ
            const legGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.1, 16);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            
            const legPositions = [
                [-standWidth/2 + 0.05, 0.06, -standDepth/2 + 0.05],  // Левая передняя
                [standWidth/2 - 0.05, 0.06, -standDepth/2 + 0.05],   // Правая передняя
                [-standWidth/2 + 0.05, 0.06, standDepth/2 - 0.05],   // Левая задняя
                [standWidth/2 - 0.05, 0.06, standDepth/2 - 0.05]     // Правая задняя
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(pos[0], pos[1], pos[2]);
                tvGroup.add(leg);
            });
            
            // ДЕКОРАТИВНАЯ ПАНЕЛЬ СПЕРЕДИ (опционально)
            const frontPanelGeometry = new THREE.BoxGeometry(standWidth - 0.07, 0.2, 0.02);
            const frontPanelMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const frontPanel = new THREE.Mesh(frontPanelGeometry, frontPanelMaterial);
            frontPanel.position.set(0, 0.2, standDepth/2 - 0.06);
            tvGroup.add(frontPanel);
            
            return tvGroup;
        }

        // Обновленная функция добавления мебели
        function addDetailedFurniture(length, width, height) {
            // Clear existing furniture
            furniture.forEach(item => scene.remove(item));
            furniture = [];
            
            // TV И ПОДСТАВКА У СТЕНЫ С ДВЕРЬЮ (задняя стена)
            const tvWithStand = createTVWithStand(length, width, height);
            // Размещаем у задней стены, смещаем от двери
            tvWithStand.position.set(length/3, 0, -width/2 + 0.2); // Правая часть задней стены
            tvWithStand.castShadow = true;
            furniture.push(tvWithStand);
            scene.add(tvWithStand);
            
            // КНИЖНАЯ ПОЛКА У ЛЕВОЙ СТЕНЫ
            createDetailedBookshelf(-length/2 + 0.2, 0.9, -width/8);
            
            // ЖУРНАЛЬНЫЙ СТОЛИК В ЦЕНТРЕ
            createDetailedCoffeeTable(0, 0.2, 0);
            
            // КРЕСЛО У ФРОНТАЛЬНОЙ СТЕНЫ
            createDetailedArmchair(0, 0.4, width/2 - 1.0);
        
        }

        // Create detailed coffee table
        function createDetailedCoffeeTable(x, y, z) {
            const tableGroup = new THREE.Group();
            
            // Table top
            const tableTop = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.4, 0.05, 32),
                new THREE.MeshStandardMaterial({ color: 0xDEB887 })
            );
            tableTop.position.y = 0.22;
            tableGroup.add(tableTop);
            
            // Table legs
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const leg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, 0.5, 16),
                    legMaterial
                );
                leg.position.set(
                    Math.cos(angle) * 0.3,
                    +0.0001,
                    Math.sin(angle) * 0.3
                );
                tableGroup.add(leg);
            }
            
            tableGroup.position.set(x, y, z);
            tableGroup.castShadow = true;
            furniture.push(tableGroup);
            scene.add(tableGroup);
        }

        function createDetailedArmchair(x, y, z, rotationY = 0) {}

        // Update 3D room
        function update3DRoom() {
            createDetailedRoom();
        }

function update3DFloorTexture() {
    if (!floor) return;
    
    console.log('Обновление пола, цвет:', currentTextureColor);
    
    // Создаем текстуру ламината
    const textureURL = createLaminateTexture(currentTextureColor);
    
    // В обработчике успешной загрузки текстуры:
    textureLoader.load(
        textureURL,
        function(texture) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            
            const length = parseFloat(roomLengthInput.value);
            const width = parseFloat(roomWidthInput.value);
            
            texture.repeat.set(length / 1.2, width / 0.2);
            
            if (floor.material.map) {
                floor.material.map.dispose();
            }
            
            floor.material.map = texture;
            floor.material.color = new THREE.Color(currentTextureColor);
            floor.material.needsUpdate = true;
            
            // ОБНОВЛЯЕМ ПЛИНТУСЫ ПОСЛЕ ОБНОВЛЕНИЯ ПОЛА
            updateBaseboardsColor();
        },
        undefined,
        function(error) {
            floor.material.map = null;
            floor.material.color = new THREE.Color(currentTextureColor);
            floor.material.needsUpdate = true;
            
            // ОБНОВЛЯЕМ ПЛИНТУСЫ ДАЖЕ ЕСЛИ ТЕКСТУРА НЕ ЗАГРУЗИЛАСЬ
            updateBaseboardsColor();
        }
    );
}

        // Set camera view
        function setCameraView(viewType) {
            if (!camera) return;
            
            const length = parseFloat(roomLengthInput.value);
            const width = parseFloat(roomWidthInput.value);
            
            switch(viewType) {
                case 'top':
                    camera.position.set(0, 15, 0.1);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'perspective':
                    camera.position.set(length * 1.2, length * 0.8, width * 1.2);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'reset':
                    camera.position.set(8, 8, 8);
                    camera.lookAt(0, 0, 0);
                    break;
            }
            controls.update();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (controls) {
                controls.update();
            }
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Handle window resize
        function onWindowResize() {
            const container = document.getElementById('room-3d');
            if (!container || !camera || !renderer) return;
            
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Функция для загрузки цвета из БД
async function loadColorFromDatabase(productId) {
    try {
        console.log('Загрузка данных о продукте из БД...');
        
        const response = await fetch(`http://127.0.0.1:8090/api/collections/laminate/records/${productId}`);
        
        if (response.ok) {
            const product = await response.json();
            console.log('Данные из БД:', product);
            
            // Извлекаем цвет из данных
            if (product.color) {
                let color = '';
                
                if (Array.isArray(product.color) && product.color.length > 0) {
                    color = product.color[0]; // Берем первый цвет из массива
                    
                    // Если есть свойство select, берем выбранный цвет
                    if (product.select && product.color.includes(product.select)) {
                        color = product.select;
                    }
                } else if (typeof product.color === 'string') {
                    color = product.color;
                }
                
                if (color) {
                    console.log('Цвет из БД:', color);
                    applyColorToConstructor(color);
                    
                    // Обновляем название продукта если нужно
                    if (product.name && !document.getElementById('selected-product-name').textContent) {
                        document.getElementById('selected-product-name').textContent = product.name;
                    }
                }
            }
        } else {
            console.warn('Не удалось загрузить данные из БД, статус:', response.status);
        }
    } catch (error) {
        console.error('Ошибка загрузки из БД:', error);
    }
}

async function initializeConstructorFromURL() {
    console.log('Инициализация конструктора...');
    
    // Загружаем все цвета из БД
    const allColors = await loadAllColorsFromDB();
    
    // Загружаем кругляшки с цветами
    loadTextures();
    
    // Получаем данные из URL
    const urlParams = new URLSearchParams(window.location.search);
    const productId = urlParams.get('product_id');
    const colorFromURL = urlParams.get('color');
    
    let colorToApply = '';
    let productNameToShow = '';
    
    // Если есть цвет в URL, применяем его
    if (colorFromURL) {
        colorToApply = decodeURIComponent(colorFromURL);
        console.log('Цвет из URL:', colorToApply);
    }
    
    // Если есть название продукта в URL, показываем его
    const productNameFromURL = urlParams.get('product_name');
    if (productNameFromURL) {
        productNameToShow = decodeURIComponent(productNameFromURL);
        console.log('Название из URL:', productNameToShow);
    }
    
    // Отображаем информацию о продукте
    if (productNameToShow) {
        let productNameElement = document.getElementById('selected-product-name');
        if (!productNameElement) {
            productNameElement = document.createElement('div');
            productNameElement.id = 'selected-product-name';
            productNameElement.className = 'selected-product-name';
            productNameElement.style.cssText = `
                background: #f8f9fa;
                padding: 10px 15px;
                border-radius: 5px;
                margin: 10px 0;
                border-left: 4px solid #e74c3c;
                font-weight: bold;
            `;
            
            const firstPanel = document.querySelector('.panel-section');
            if (firstPanel) {
                firstPanel.insertBefore(productNameElement, firstPanel.firstChild);
            }
        }
        productNameElement.textContent = `Выбранный продукт: ${productNameToShow}`;
    }
    
    // Применяем цвет (с увеличенной задержкой для гарантированной загрузки кругляшков)
    if (colorToApply) {
        console.log('Применяем цвет к конструктору:', colorToApply);
        
        // Первая попытка через 800мс
        setTimeout(() => {
            applyColorToConstructor(colorToApply, true);
        }, 800);
        
        // Вторая попытка через 1.5 секунды на случай если кругляшки еще грузятся
        setTimeout(() => {
            // Проверяем, отметился ли цвет
            const selectedCircles = document.querySelectorAll('.color-circle-option.selected');
            if (selectedCircles.length === 0) {
                console.log('Повторная попытка применить цвет');
                applyColorToConstructor(colorToApply, true);
            }
        }, 1500);
    }
}

// Функция для создания кругляшков с цветами из БД
function createColorCircles(colors) {
    console.log('Создание цветовых кругляшков в ряд:', colors);
    
    const container = document.getElementById('textures-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    if (!colors || colors.length === 0) {
        const placeholder = document.createElement('div');
        placeholder.className = 'texture-placeholder';
        placeholder.textContent = 'Цвета не найдены';
        container.appendChild(placeholder);
        return;
    }
    
    // Сортируем цвета для красивого отображения
    const sortedColors = [...colors].sort((a, b) => {
        if (!a || !b) return 0;
        return a.localeCompare(b);
    });
    
    // Создаем контейнер для всех цветов (без групп)
    const colorsContainer = document.createElement('div');
    colorsContainer.className = 'colors-container';
    
    // Ограничиваем количество отображаемых цветов (например, первые 20)
    const displayColors = sortedColors.slice(0, 20);
    
    displayColors.forEach(colorText => {
        if (!colorText || typeof colorText !== 'string') return;
        
        const trimmedColor = colorText.trim();
        if (!trimmedColor) return;
        
        const colorCircle = createSingleColorCircle(trimmedColor);
        colorsContainer.appendChild(colorCircle);
    });
    
    container.appendChild(colorsContainer);
    
    // Если цветов больше, чем отображаем, показываем сообщение
    if (sortedColors.length > displayColors.length) {
        const moreInfo = document.createElement('div');
        moreInfo.className = 'more-colors-info';
        moreInfo.textContent = `... и еще ${sortedColors.length - displayColors.length} цветов`;
        moreInfo.style.cssText = `
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-top: 10px;
            font-style: italic;
        `;
        container.appendChild(moreInfo);
    }
}

// Функция для создания одного кругляшка
function createSingleColorCircle(colorText) {
    const colorCircle = document.createElement('div');
    colorCircle.className = 'color-circle-option';
    colorCircle.dataset.color = colorText;
    colorCircle.title = colorText;
    
    // Получаем HEX цвет
    const colorHex = getColorHex(colorText);
    
    // Создаем кругляшок с цветом
    const circle = document.createElement('div');
    circle.className = 'color-circle';
    circle.style.backgroundColor = colorHex;
    
    // Добавляем галочку для выбранного цвета
    const checkmark = document.createElement('div');
    checkmark.className = 'color-checkmark';
    checkmark.innerHTML = '✓';
    checkmark.style.display = 'none';
    
    const colorName = document.createElement('div');
    colorName.className = 'color-circle-name';
    colorName.textContent = colorText.length > 10 ? colorText.substring(0, 10) + '...' : colorText;
    
    circle.appendChild(checkmark);
    colorCircle.appendChild(circle);
    colorCircle.appendChild(colorName);
    
    // Проверяем, является ли этот цвет текущим выбранным
    if (currentTextureColor && getColorHex(colorText) === currentTextureColor) {
        colorCircle.classList.add('selected');
        checkmark.style.display = 'block';
    }
    
    // Обработчик клика
    colorCircle.addEventListener('click', function() {
        console.log('Выбран цвет:', colorText);
        
        // Убираем выделение у всех кругляшков
        document.querySelectorAll('.color-circle-option').forEach(opt => {
            opt.classList.remove('selected');
            const check = opt.querySelector('.color-checkmark');
            if (check) check.style.display = 'none';
        });
        
        // Добавляем выделение текущему
        this.classList.add('selected');
        checkmark.style.display = 'block';
        
        // Обновляем текущий материал
        if (currentMaterialDisplay) {
            currentMaterialDisplay.textContent = colorText;
        }
        
        // Обновляем глобальную переменную цвета
        currentTextureColor = colorHex;
        
        // Обновляем пол
        if (floor) {
            update3DFloorTexture();
        }
        
        // Обновляем плинтусы
        updateBaseboardsColor();
    });
    
    return colorCircle;
}
function applyColorToConstructor(color, skipEventTrigger = false) {
    if (!color || typeof color !== 'string') {
        return;
    }
    
    const normalizedColor = color.trim();
    if (!normalizedColor) return;
    
    console.log('Применение цвета к конструктору:', normalizedColor);
    
    const colorHex = getColorHex(normalizedColor);
    
    // Обновляем глобальную переменную
    currentTextureColor = colorHex;
    
    // 1. Находим и отмечаем соответствующий кругляшок
    const colorCircles = document.querySelectorAll('.color-circle-option');
    let found = false;
    
    colorCircles.forEach(circle => {
        const circleColor = circle.dataset.color;
        if (circleColor && circleColor.toLowerCase() === normalizedColor.toLowerCase()) {
            found = true;
            
            // Убираем выделение у всех
            document.querySelectorAll('.color-circle-option').forEach(opt => {
                opt.classList.remove('selected');
                const check = opt.querySelector('.color-checkmark');
                if (check) check.style.display = 'none';
            });
            
            // Добавляем выделение найденному
            circle.classList.add('selected');
            const checkmark = circle.querySelector('.color-checkmark');
            if (checkmark) {
                checkmark.style.display = 'block';
            }
            
            // Прокручиваем к выбранному элементу
            circle.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
    });
    
    if (!found) {
        console.log('Цвет не найден в кругляшках, возможно кругляшки еще не загрузились');
        // Сохраняем цвет для применения после загрузки кругляшков
        setTimeout(() => {
            applyColorToConstructor(normalizedColor, skipEventTrigger);
        }, 500);
        return;
    }
    
    // 2. Обновляем отображение текущего материала
    if (currentMaterialDisplay) {
        currentMaterialDisplay.textContent = normalizedColor;
    }
    
    // 3. Обновляем пол и плинтусы
    if (floor) {
        update3DFloorTexture();
    }
    
    // 4. Обновляем плинтусы (даже если пол еще не создан)
    updateBaseboardsColor();
}

// Функция для прокрутки к выбранному цвету
function scrollToSelectedColor(colorText) {
    const colorCircles = document.querySelectorAll('.color-circle-option');
    
    colorCircles.forEach(circle => {
        if (circle.dataset.color && circle.dataset.color.toLowerCase() === colorText.toLowerCase()) {
            // Прокручиваем контейнер к выбранному цвету
            const container = document.getElementById('textures-container');
            if (container) {
                const containerRect = container.getBoundingClientRect();
                const circleRect = circle.getBoundingClientRect();
                
                // Если цвет за пределами видимой области, прокручиваем
                if (circleRect.left < containerRect.left || circleRect.right > containerRect.right) {
                    circle.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                }
            }
        }
    });
}

// Функция для обновления предпросмотра с цветом
function updatePreviewWithColor(normalizedColor, displayColor) {
    console.log('Обновление предпросмотра с цветом:', normalizedColor, 'Отображаемый цвет:', displayColor);
    
    // Обновляем текущий материал в UI
    const currentMaterialDisplay = document.getElementById('current-material');
    if (currentMaterialDisplay) {
        currentMaterialDisplay.textContent = displayColor || normalizedColor;
    }
    
    // Обновляем цвет в выпадающем списке без триггера события
    applyColorToConstructor(normalizedColor, true);
}

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(init, 100);
        });

        // В функции setupEventListeners замените обработчик для плинтусов
        document.getElementById('plinth').addEventListener('change', function(e) {
            const isChecked = e.target.checked;
            toggleBaseboards(isChecked);
            calculateCost();
        });
    </script>
</body>
</html>